{Вычисление собственных чисел и собственных векторов}
{Программа написана для компиляторов Turbo Pascal/Borland Pascal фирмы Borland inc.}
uses Crt;

type
	MatrType = array[1..3, 1..3] of Real;     {Тип, описывающий матрицу [3x3]}
	VectorType = array[1..3] of Real;        {Вектор из 3-х элементов}

const
	{исходная матрица}
	MyMatr:MatrType =
		((1, 2, -1),
			(3, 0, 2),
			(4, -2, 5));

	{единичная матрица}
	EM:MatrType =
		((1, 0, 0),
			(0, 1, 0),
			(0, 0, 1));

	{размерность заданной матрицы}
	N : integer = 3;

{вычисление характеристического полинома в точке X
(используется в решении уравнения P(lambda)=0 методом Ньютона)}
Function F(X : Real; P : VectorType) : Real;
{Входные параметры:
	X - значение X,
	P - коэффициенты p1,..,pn (элементы матрицы Фробениуса).
	Выходной параметр:
	F - значение характеристического полинома в точке X.}
begin
	F := (-1) * (Sqr(X) * X - P[1] * Sqr(X) - P[2] * X - P[3]);
end;

{вычисление значения производной первого порядка
	от характеристического полинома в точке X
(используется в решении уравнения D(lambda)=0 методом Ньютона)}
Function dF(X : Real; P : VectorType) : Real;
{Входные параметры:
	X - значение X,
	P - коэффициенты p1,..,pn (элементы матрицы Фробениуса).
	Выходной параметр:
	dF - значение производной первого порядка от
		 характеристического полинома в точке X.}
begin
	dF := (-1) * (3 * Sqr(X) - 2 * P[1] * X - P[2]);
end;

{умножение матрицы на матрицу}
Procedure MxM(A, B : MatrType; var X : MatrType);
{Входные параметры:
	A,B - перемножаемые матрицы.
	Выходной параметр:
	X - матрица - результат операции умножения.}
var
	i, j, k : integer;
	s : real;
begin
	for i := 1 to N do
		for j := 1 to N do
			begin
				S := 0;
				for k := 1 to N do
					s := s + A[i, k] * B[k, j];
				X[i, j] := s;
			end;
end;

{умножение матрицы на вектор}
Procedure MxV(A: MatrType; V: VectorType; var X: VectorType);
{Входные параметры:
	A - матрица (первый множитель),
	V - вектор (второй множитель),
	X - вектор, в котором хранятся результаты вычислений}
var
	i, j : integer;
	s : real;
begin
	for i := 1 to N do
	begin
		s := 0;
		for j := 1 to N do
			s := s + A[i, j] * v[j];
		X[i] := s;
	end;
end;


Procedure Lab3(Matr : MatrType; var L : VectorType; var X, Ax, Lx : MatrType);
(*Входные параметры:
	 Matr:MatrType    -  квадратная матрица, для которой
						 находятся собственные значения;
	 Выходные параметры:
	 L:VectorType     -  массив [1..N] собственных чисел;
	 X:MatrType       -  двумерный массив, строки которого содержат
						  собственные векторы
	 Ax,Lx:MatrType - матрицы, строки которых содержат результаты проверки 
						  A*x(i) и L(i)*x(i) соответственно*)

var
	i, j, k, h : integer;   	{вспомогательные переменные}
	P : MatrType;        		{матрица Фробениуса}
	Pvec : VectorType;   		{вектор коэффициентов (p1,p2,p3)}
	A, B, A1, B1 : real;    	{границы интервалов (метод Ньютона)}
	E : real;            		{точность вычисления (метод Ньютона)}
	lam0, lam1 : real;    		{вспомогательные переменные (метод Ньютона)}
	S : MatrType;        		{неособенная матрица S=M(n-1)*...*M1}
	M, M1 : MatrType;     		{матрицы, используемые в преобразовании подобия}
	Yi : VectorType;     		{собственный вектор матрицы Фробениуса,
									соответствующий i-му собственному числу}
	Xi : VectorType;      		{i-й собственный вектор исходной матрицы}
	Axi, Lxi : VectorType; 		{векторы с результатами проверки правильности вычисления
						  			i-го собственного вектора исходной матрицы}

	{рекурсивная процедура вычисления
		матрицы Фробениуса и неособенной матрицы S}
	procedure Frob(A : MatrType; Num : integer);
	var i, j : integer;
	begin
		if Num - 1 > 0 then
		begin
	
			M := EM;
			M1 := EM;
			for i := 1 to N do
			begin
				{Вычисление матриц M(n-1),...,M1}
				if i = Num - 1 then
					M[Num - 1, i] := 1 / A[Num, Num - 1]
				else
					M[Num - 1, i] := -A[Num, i] / A[Num, Num - 1];
				{Вычисление матриц M(n-1)^-1,...,M1^-1}
				M1[Num - 1, i] := A[Num, i];
			end;

			{Вычисление неособенной матрицы S}
			MxM(S, M, S);
			{Преобразование подобия}
			MxM(A, M, A);
			MxM(M1, A, A);
			P := A;
			Frob(A, Num - 1);
		end;
	end;

	Begin
		clrscr;
		{нахождение матрицы Фробениуса}
		S := EM;
		Frob(Matr, N);

		{выделение вектора p=(p1,p2,p3)}
		for i := 1 to N do
			Pvec[i] := P[1, i];

		{решение уравнения P(lambda)=0 с использованием метода Ньютона
		для нахождения собственных чисел}
		A := -5; B := 5;                   {интервал для поиска корней}
		h := 10;                         {количество узлов}
		E := 0.0001;                     {точность решения}
		j := 1;

		for i := 0 to h do
			{отделение корней}
			if F((A + i * (B - A) / h), Pvec) *
				F((A + (i + 1) * (B - A) / h), Pvec) < 0 then
			begin
				{[A1, B1] - интервал,  на котором находится корень}
				A1 := A + i * (B - A) / h;
				B1 := A + (i + 1) * (B - A) / h;
				{метод Ньютона}
				lam1 := (A1 + B1) / 2;
				repeat
					lam0 := lam1;
					lam1 := lam0 - F(lam0, Pvec) / dF(lam0, Pvec);
				until Abs(lam1 - lam0) < E;
				{внесение найденного i-го собственного
				числа в массив собственных чисел}
				L[j] := lam1;
				j := j + 1;
			end;

		{нахождение собственных векторов}
		for i := 1 to N do
		begin
			{нахождение i-го собственного вектора матрицы Фробениуса}
			Yi[N] := 1;
			for j := N - 1 downto 1 do
				Yi[j] := L[i] * Yi[j + 1];
			{нахождение i-го собственного вектора исходной матрицы
			путем умножения неособенной матрицы S=M(n-1) * ... * M1
			на соответствующий собственный вектор матрицы Фробениуса}
			MxV(S, Yi, Xi);
			for j := 1 to N do
				X[i, j] := Xi[j];

			{Проверка правильности вычисления собственных векторов}
			MxV(Matr, Xi, Axi);
			for j := 1 to N do 
			begin
				Ax[i, j] := Axi[j];
				Lx[i, j] := L[i] * Xi[j];
			end;
		
		end;

	End;

var
	(* Выходные данные:      *)
	X : MatrType;     {Матрица собственных векторов}
	L : VectorType;   {Вектор собственных чисел}
	Ax, Lx : MatrType;
	(* Вспомогательные переменные *)
	{N:Integer;      {Размерность матрицы}
	i, j : Integer;
Begin
	N := 3;
	Lab3(MyMatr, L, X, Ax, Lx); {вычисление собственных чисел и векторов}
	{Вывод результатов}
	WriteLn('Собственные числа:');
	for i := 1 to N do
		WriteLn('L(', i, ') = ', L[i]:1:5);
	Writeln;
	WriteLn('Собственные векторы:');
	for i := 1 to N do
	begin
		write('x(', i, ') = ');
		for j := 1 to N do
			Write(X[i, j]:1:5, ' ');
		writeln;
	end;
	Writeln;
	Writeln('Проверка A * x(i)=L(i) * x(i):');
	for i := 1 to N do
	begin
		write('A * x(', i, ')    = ');
		for j := 1 to N do
			write(Ax[i, j]:2:4, ' ');
		writeln;
		write('L(', i, ') * x(', i, ') = ');
		for j := 1 to N do
			write(Lx[i, j]:2:4, ' ');
		writeln;
	end;

	readln;
End.
